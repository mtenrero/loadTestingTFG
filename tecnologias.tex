\cleardoublepage
\chapter{Tecnologías, Herramientas y Metodologías}

Aquí me gustaría hablar de los siguientes temas:



\begin{enumerate}
  \item \textbf{Lenguaje Golang:} Carácteristicas básicas del lenguaje, cross-platform, cobertura de test
  \item \textbf{Git, Travis \& Jenkins:} Diferencias y features críticas que me han hecho pasar de Travis a Jenkins
  \item \textbf{Swagger:}
  \item \textbf{Goa Design:} Paquete Golang, Design First API, creo que es importante por el carácter de piensa antes de picar, muy similar a TDD
  \item \textbf{AWS} Toda la CI está desplegada en AWS y tengo pensado montar un cluster Swarm aquí para una futura demo.
  \item \textbf{Docker}
  \item \textbf{ElasticSearch} Características básicas
  \item \textbf{Shared Filesystem:} GlusterFS / Samba . No es Kubernetes, asi que se necesita esta configuración previa para tener todos los ficheros disponibles en todo el cluster. Explicar lo que ofrece y por qué es necesario.
  \item \textbf{Redes:} Concretamente DNS y algoritmo DNS Round Robin. Es la piedra angular en cuanto a orquestación con arquitectura Master / Workers se refiere
  \item \textbf{Apache Jmeter:} Forma de ejecución distribuida y arquitectura
\end{enumerate}

\section{Golang}

Go es un lenguaje de programación que se comenzó a desarrollar en 2007 \cite{Pike:2012:GG:2384716.2384720} y nació con el ideal de eliminar todos los obstáculos de la programación actual \cite{donovan2015go}, ya que desde hace varios años no había salido ningún lenguaje de programación de alta importancia. Se necesitaba que estuviese diseñado por completo, teniendo en cuenta factores de la informática actual, como la concurrencia o la rapidez en la compilación y en la codificación.

Los orígenes de Go se remontan a los lenguajes Oberon 2 , C y Alef \cite{donovan2015go}. Nace como un proyecto de Google como solución para la codificación de soluciones complejas.

Como particular característica \cite{pike2009go}, Go es un lenguaje de programación con recolector de basura, para permitir así trabajar de una forma correcta con la concurrencia de las aplicaciones. \newline

 El compilador de Go se ideó de tal forma para que fuese compatible nativamente con todos los Sistemas Operativos, introduciendo el cross-compile (Compilación para otras plataformas o arquitecturas en un único Sistema Operativo) como uno de sus puntos fuertes.
 
\section{Dep: Go Dependency Management}

Uno de los puntos fuertes de Go, es la gestión de dependencias durante la compilación \cite{pike2009go}. Sin embargo, de cara al desarrollador, por defecto, carece de un fichero a nivel global de proyecto para poder definir las dependencias del mismo y/o la versión con la que se desea trabajar, sino que se debe especificar a través de sentencias \textit{import} en los ficheros \textit{.go} del código. Además, para poder usar esas dependencias, es necesario que estén presentes en el \$GOPATH del sistema.\newline

Dep nace como un experimento de Golang\footnote{https://github.com/golang/dep} , preparada para usar en producción, aunque sin llegar a ser la herramienta oficial de gestión de dependencias a nivel de proyecto/usuario. Emplea un fichero TOML en la raiz del proyecto, en él se indica la dependencia requerida, su versión e incluso la rama del control de versiones desde la cual obtener los paquetes. \newline

\section{Goa Design: Design-first Network framework}

Goa\footnote{https://goa.design} es un framework completo para construir microservicios en Go que invierte la forma de construir APIs web completamente. Posee generación automática de código y documentación. \newline

Es un framework enfocado al diseño de la API en primer lugar, y es lo que hace a este framework único. Posee su propio lenguaje DSL (lenguaje descriptivo) en el que antes de codificar, obliga al programador a pensar en el diseño de la API, ya que esta debe ser definida en un primer lugar. Permite definir desde el endpoint, el contenido que consumirá y los parámetros que recibirá.

\section{OpenAPI Specification}

OpenAPI es una especificación mantenida e ideada por la comunidad Open-Source en la plataforma GitHub\footnote{https://github.com/OAI/OpenAPI-Specification}, independiente de cualquier lenguaje de programación, que permite definir cualquier tipo con toda la especificación completa de una API, para que sea comprensible, tanto para personas como para ordenadores, ya que se basa en ficheros JSON y YAML.

\section{DNS}

Domain Name System es un sistema de nombrado de redes IP que se utiliza para resolver nombres en direcciones IP. El servicio de resolución de nombres puede tener diferentes tipos de registros. En la investigación del trabajo sólo se han usado registros de tipo \textbf{A}, los cuales traducen un nombre en una o varias direcciones IP, dependiendo de los registros A que tenga almacenados para un mismo nombre de dominio/subdominio.

\subsection{DNS Round-Robin}

DNS Round-Robin es un algoritmo de selección de IP, en el que con cada petición que realiza el usuario, se obtiene una lista completa de todas las direcciones IP registradas en el servidor de nombres ordenada de tal forma que nunca recibe la misma IP, realizando, de esta manera, labores de balanceador de carga.

Docker implementa este algoritmo de forma alternativa en su DNS interno, y el desarrollador puede elegir si desea operar con DNS Round Robin o con \textit{Routing Mesh}, balanceo de carga interno, donde el nombre es resuelto con una única IP Virtual de manera no determinista.\newline

Cuando se opta por usar el modo DNS Round-Robin, por limitaciones de diseño, resulta imposible exponer puertos hacia el host, únicamente se permiten conexiones de red con las redes indicadas por el servicio. 