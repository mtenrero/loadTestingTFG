\cleardoublepage
\chapter{Tecnologías y Herramientas}

\section{Golang}

Go es un lenguaje de programación que se comenzó a desarrollar en 2007 \cite{Pike:2012:GG:2384716.2384720} y nació con el ideal de eliminar todos los obstáculos de la programación actual \cite{donovan2015go}, ya que desde hace varios años no había sido desarrollado ningún lenguaje de programación de alta importancia. Se necesitaba que estuviese diseñado por completo, teniendo en cuenta factores de la informática actual, como la concurrencia o la rapidez en la compilación y en la codificación.

Los orígenes de Go se remontan a los lenguajes Oberon 2 , C y Alef \cite{donovan2015go}. Nace como un proyecto de Google como solución para la codificación de soluciones complejas.

Como particular característica \cite{pike2009go}, Go es un lenguaje de programación con recolector de basura, para permitir así trabajar de una forma correcta con la concurrencia de las aplicaciones. \newline

 El compilador de Go se ideó de tal forma para que fuese compatible nativamente con todos los Sistemas Operativos, introduciendo el cross-compile (Compilación para otras plataformas o arquitecturas en un único Sistema Operativo) como uno de sus puntos fuertes.
 
\section{Dep: Go Dependency Management}

Uno de los puntos fuertes de \textit{Go}, es la gestión de dependencias durante la compilación \cite{pike2009go}. Sin embargo, de cara al desarrollador, por defecto, carece de un fichero a nivel global de proyecto para poder definir las dependencias del mismo y/o la versión con la que se desea trabajar, sino que se debe especificar a través de sentencias \textit{import} en los ficheros \textit{.go} del código. Además, para poder usar esas dependencias, es necesario que estén presentes en el \$GOPATH del sistema.\newline

\textit{Dep} nace como un experimento de \textit{Golang}\footnote{https://github.com/golang/dep} , preparada para usar en producción, aunque sin llegar a ser la herramienta oficial de gestión de dependencias a nivel de proyecto/usuario. Emplea un fichero TOML en la raíz del proyecto, en él se indica la dependencia requerida, su versión e incluso la rama del control de versiones desde la cual obtener los paquetes. \newline

\section{Goa Design: Design-first Network framework}

Goa\footnote{https://goa.design} es un framework completo para construir microservicios en Go que invierte la forma de construir APIs web completamente. Posee generación automática de código y documentación. \newline

Es un framework enfocado al diseño de la API en primer lugar, y es lo que hace a este framework único. Posee su propio lenguaje DSL (lenguaje descriptivo) en el que antes de codificar, obliga al programador a pensar en el diseño de la API, ya que esta debe ser definida en un primer lugar. Permite definir desde el endpoint, el contenido que consumirá y los parámetros que recibirá.

\section{OpenAPI Specification}

OpenAPI es una especificación mantenida e ideada por la comunidad Open-Source en la plataforma GitHub\footnote{https://github.com/OAI/OpenAPI-Specification}, independiente de cualquier lenguaje de programación, que permite definir cualquier tipo con toda la especificación completa de una API, para que sea comprensible, tanto para personas como para ordenadores, ya que se basa en ficheros JSON y YAML.

\section{DNS}

Domain Name System es un sistema de nombrado de redes IP que se utiliza para resolver nombres en direcciones IP. El servicio de resolución de nombres puede tener diferentes tipos de registros. En la investigación del trabajo sólo se han usado registros de tipo \textbf{A}, los cuales traducen un nombre en una o varias direcciones IP, dependiendo de los registros A que tenga almacenados para un mismo nombre de dominio o subdominio.

\subsection{DNS Round-Robin}

DNS Round-Robin es un algoritmo de selección de IP, en el que con cada petición que realiza el usuario, se obtiene una lista completa de todas las direcciones IP registradas en el servidor de nombres ordenada de tal forma que nunca recibe la misma IP, realizando, de esta manera, labores de balanceador de carga.

Docker implementa este algoritmo de forma alternativa en su DNS interno, y el desarrollador puede elegir si desea operar con DNS Round Robin o con \textit{Routing Mesh}, balanceo de carga interno, donde el nombre es resuelto con una única IP Virtual de manera no determinista.\newline

Cuando se opta por usar el modo DNS Round-Robin, por limitaciones de diseño, resulta imposible exponer puertos hacia el host, únicamente se permiten conexiones de red con las redes indicadas por el servicio. 

\section{Contenedores}

Los contenedores son un nuevo tipo de virtualización ligera de Sistemas Operativos que no requieren la emulación de instrucciones en el procesador, reduciendo así el consumo de recursos sin prescindir del aislamiento necesario presente en la virtualización tradicional \cite{containerVsHyper}.

\subsection{LXC: Linux Containers}

LXC es un tipo de virtualización basada en contenedores, usa el espacio de nombres de kernel y cgroups para asegurar el aislamiento de los contenedores, aunque los contenedores comparten el kernel con el Sistema Operativo del host \cite{ContainersComparison}.

\subsection{Docker}

Docker añade una capa para gestionar las redes de los contenedores dotándolos de una IP propia y el sistema de ficheros a LXC. Permite especificar imágenes de contenedores autocontenidas y gestionar el ciclo de vida de ellos. 
\cite{containerVsHyper} \cite{fromLXCtoKubernetes}. Introduce un modelo cliente-servidor, siendo el demonio de Docker en el host el responsable de la comunicación con los contenedores \cite{ContainersComparison} \newline 

Docker ofrece además un repositorio o registro donde almacenar estas imágenes de los contenedores para que estén disponibles para su uso
\cite{Merkel:2014:DLL:2600239.2600241}
de manera pública a través de DockerHub\footnote{https://hub.docker.com}, o de manera privada con un registro desplegado a demanda.

Docker usa una terminología propia:

\begin{itemize}
  \item \textbf{Imagen:} Descripción de los contenidos de un contenedor, interoperable entre todo el ecosistema Docker.
  \item \textbf{Contenedor:} Es la unidad mínima en Docker, corresponde a una imagen ejecutada sobre una máquina o Swarm.
  \item \textbf{Volumen:} Unidad de almacenamiento persistente en Docker, pueden ser bindados a un directorio o fichero del sistema de ficheros del host o en el propio contexto de Docker.
  \item \textbf{Servicio:} Encapsulación de una imagen que se puede configurar de manera concreta. Permitiendo configurar la cantidad de replicas a desplegar, el tipo de red o los volúmenes con los que trabajar.
  \item \textbf{Red:} Red dentro del ecosistema Docker, se encarga de interconectar Servicios y/o Contenedores
\end{itemize}


\subsubsection{Raft Consensus}

Es un algoritmo para asegurar tolerancia a fallos. Para su correcto funcionamiento, se tiene que establecer un \textit{Quorum}, un conjunto de nodos elegidos para administración. El tamaño del \textit{Quorum} se define por la siguiente ecuación \( 2f + 1 \), siendo \( f \) la cantidad de fallos a tolerar. Por lo tanto, para formar \textit{Quroum}, serán necesarios un mínimo de 3 nodos \cite{Raft-UCAM-CL-TR-857} .

\subsubsection{Docker Swarm}

Docker Swarm es un modo de funcionamiento de Docker que permite utilizar diversas máquinas para formar un clúster de Docker en el que desplegar contenedores, donde el demonio de Docker gestiona la red, el sistema de ficheros y la comunicación entre servicios.\newline

Para desplegar diversos Servicios en un Swarm, Docker introduce el concepto de \textbf{Stack}, una agrupación de Servicios con su configuración de red particular.\newline 

Los nodos de Docker Swarm pueden tener dos roles:

\begin{itemize}
  \item \textbf{Manager:} Gestionan el clúster, como mínimo, debe haber 3 Managers para que se puede aplicar Raft-Consensus. Tienen una visión completa del cluster. A su vez, uno de ellos se elegirá como \textbf{Líder}, el cual será responsable de la gestión del clúster. 
  \item \textbf{Worker:} Son nodos en los cuales sólo se despliegan contenedores o servicios, sólo tienen visión de los contenedores o servicios que están desplegados en el propio nodo.
\end{itemize}


\section{Apache JMeter}

Apache JMeter es un software de código abierto desarrollado en Java con el objetivo de realizar test de rendimiento automáticos.
Tiene una baja curva de aprendizaje y permite ejecutar las pruebas de manera distribuida y una API pública lo que permite extender el funcionamiento de la herramienta a demanda. 


Está dotado de interfaz de usuario gráfica desde la cual se pueden diseñar y ejecutar tests, pero también ofrece una versión de ejecución por línea de comandos que permite automatizar completamente el lanzamiento de las pruebas.


\subsubsection{Ejecución distribuida}

JMeter se desarrolló pensando en un esquema de ejecución distribuida \textbf{Maestro} / \textbf{Esclavos}. Los esclavos deben estar accesibles antes de la ejecución del test a través del nodo maestro.\newline

El lanzamiento del nodo Maestro requiere que se especifique la lista de los nodos remotos que utilizar para lanzar el test de rendimiento.


\section{ElasticSearch}

ElasticSearch forma parte del Stack ELK (\textit{ElasticSearch}, \textit{Logstash}, \textit{Kibana}) y es una base de datos y motor de búsqueda distribuido y enfocado a la alta disponibilidad. Está desarrollado en Java bajo una licencia open source y basado en Lucene \cite{divya2013elasticsearch}, una libreria open source de búsqueda de texto completo.

\section{Sistema de ficheros distribuido}

Un sistema de ficheros distribuido permite acceder a unos directorios o ficheros determinados desde diversos ordenadores. Cada Sistema Operativo implementa su propio protocolo de ficheros distribuidos. El sistema Operativo Windows utiliza Samba.

\subsection{Samba}

Samba es el protocolo open source por defecto de Windows que comparte directorios e impresoras como estándar. Su carácter open source permite que sea posible acceder a recursos compartidos Windows desde otros Sistemas Operativos\cite{5076771}. 

\subsection{GlusterFS}

GlusterFS\footnote{http://gluster.org} es un sistema de ficheros distribuido open source a través de la red que puede replicar los contenidos entre los nodos que lo tengan configurado. Las características principales de Gluster son las comunes a cualquier sistema distribuido, tolerancia a fallos y alta escalabilidad \cite{glusterOpenStackDeployment}.

\section{AWS: Amazon Web Services}

Amazon Web Services es una solución Platform-as-a-Service (PAAS) que ofrece diversos productos, entre ellos:

\begin{itemize}
  \item \textbf{EC2:} Recursos de cómputo bajo demanda. Permitiendo desplegar máquinas virtuales en pocos minutos con la imagen de sistema deseada, ya sea Windows o Linux.
  \item \textbf{ElasticIP:} IP pública bajo demanda
\end{itemize}


Se caracteriza por ofrecer un modelo de pago por uso y por la capacidad de interconexión entre sus servicios.

\section{Sistemas de Integración Continua}

Un Sistema de Integración Continua, permite ejecutar con cada commit. sobre el Control de Versiones, ejecutar una serie de programas definidos en un pipeline, como puede ser la ejecución de tests unitarios para asegurarse de la regresión de la aplicación, es decir, que no se ha roto ninguna funcionalidad previo con los nuevos cambios introducidos. \newline

\subsection{TravisCI}

TravisCI\footnote{https://travis-ci.com} es un servicio de Integración Continua ofrecido de manera gratuita para proyectos open-source de GitHub. Está pre-configurado para usarse de manera sencilla para una gran cantidad de lenguajes de programación así como para despliegues en servicios PAAS como es el caso de Heroku\footnote{https://www.heroku.com}. 
Usa ficheros YAML para su configuración y todos los comandos y procesos indicados en los ficheros de configuración se ejecutan sobre contenedores completamente aislados. Ofrecen Docker-In-Docker de manera limitada, únicamente para construir imágenes y publicarlas en un registro.

\subsection{Jenkins}

Jenkins es una aplicación open-source desarrollada en Java enfocada a Integración Continua y Despliegue Continuo (CI/CD), al igual que TravisCI. Es completamente configurable y versátil, aunque requiere una instalación y configuración previa. Además, aporta la flexibilidad de poder instalar o desarrollar plugins de terceros.\newline 

Permite configurar los pipelines de ejecución mediante una interfaz visual y de manera declarativa o procedural a través de código en el propio repositorio.